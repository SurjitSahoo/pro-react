"use strict";(self.webpackChunkpro_react=self.webpackChunkpro_react||[]).push([[7001],{7378:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"performance/what-are-hooks","title":"What Are Hooks? \ud83e\ude9d","description":"It is an optimization technique.","source":"@site/docs/4.performance/2.what-are-hooks.md","sourceDirName":"4.performance","slug":"/performance/what-are-hooks","permalink":"/pro-react/docs/performance/what-are-hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/SurjitSahoo/pro-react/edit/main/docs/4.performance/2.what-are-hooks.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"slug":"what-are-hooks"},"sidebar":"tutorialSidebar","previous":{"title":"Class Components Vs Function Components","permalink":"/pro-react/docs/performance/class-components-vs-function-components"},"next":{"title":"useEffect is Dangerous! \ud83e\udde8\ud83d\udca3","permalink":"/pro-react/docs/performance/use-effect-is-dangerous"}}');var o=t(4848),a=t(8453);const i={sidebar_position:2,slug:"what-are-hooks"},r="What Are Hooks? \ud83e\ude9d",c={},h=[{value:"<code>useCallback</code>",id:"usecallback",level:2},{value:"<code>useMemo</code>",id:"usememo",level:2},{value:"<code>useState</code>",id:"usestate",level:2},{value:"<code>useEffect</code>",id:"useeffect",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"what-are-hooks-",children:"What Are Hooks? \ud83e\ude9d"})}),"\n",(0,o.jsx)(n.admonition,{title:"Hooks are all about memoization",type:"info",children:(0,o.jsx)(n.p,{children:"It is an optimization technique.\nThe memoization function caches the last return value and would return the cached value if the inputs are the same as the previous function call."})}),"\n",(0,o.jsx)(n.p,{children:"Hooks memoize and protect the variables and functions within the React component from being re-created on each re-render. Different hooks memoize different things."}),"\n",(0,o.jsx)(n.p,{children:"That's the default behavior in class components, but we are trying to mimic that in function components!"}),"\n",(0,o.jsx)(n.h2,{id:"usecallback",children:(0,o.jsx)(n.code,{children:"useCallback"})}),"\n",(0,o.jsx)(n.p,{children:"This hook memoizes a function. It takes a callback function as param to memoize. Whenever the component re-renders, the useCallback function will be called again and again, and each time it'll return the exact same function reference, as long as the dependency doesn't change. So the returned function will remain same, as if it was defined outside the react-component."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:"showLineNumbers",children:"function UserComponent({ user }) {\n  const userName = useCallback(\n    // \ud83d\udc47 This function is memoized\n    // highlight-start\n    () => {\n      const name = user.name;\n      return `user: ${name}`;\n    },\n    // highlight-end\n    [user],\n  );\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, ",(0,o.jsx)(n.code,{children:"UserComponent"})," component, which a javascript function can be called as many times as required as part of re-rendering the component, but if the ",(0,o.jsx)(n.code,{children:"user"})," prop doesn't change, then ",(0,o.jsx)(n.code,{children:"userName"})," function will remain exactly same. It will not be re-created."]}),"\n",(0,o.jsxs)(n.p,{children:["But when the ",(0,o.jsx)(n.code,{children:"user"})," prop does change, then the ",(0,o.jsx)(n.code,{children:"useCallback"})," hook will return a brand new function, re-created new instance."]}),"\n",(0,o.jsx)(n.h2,{id:"usememo",children:(0,o.jsx)(n.code,{children:"useMemo"})}),"\n",(0,o.jsxs)(n.p,{children:["This hook has the exact same signature as ",(0,o.jsx)(n.code,{children:"useCallback"}),". Except, it memoizes a value, not the function. The value returned from the callback function is memoized, not the function itself. If it's dependencies don't change, it will not call the callback function it'll return the previous value which the hook has cached."]}),"\n",(0,o.jsx)(n.p,{children:"It will call the callback function for a fresh value only when the dependencies change"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:"showLineNumbers",children:"function UserComponent({ user }) {\n  const userName = useMemo(() => {\n    const name = user.name;\n    // \ud83d\udc47 This return value is memoized\n    // highlight-next-line\n    return `user: ${name}`;\n  }, [user]);\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, useMemo will call the passed callback function on the first render and return the return-value of the callback function. Then whenever the component re-renders the useMemo function will be called to get the value for ",(0,o.jsx)(n.code,{children:"userName"}),", but the useMemo will not call the callback function if the dependency: user object hasn't changed, instead it will return the previous cached value."]}),"\n",(0,o.jsx)(n.h2,{id:"usestate",children:(0,o.jsx)(n.code,{children:"useState"})}),"\n",(0,o.jsx)(n.p,{children:"It's a weird one. All other hooks memoize something that's passed to the hook function as param. But unlike other hooks, It's not memoizing the value passed to the useState function. It's memoizing the return value of the useState function. And the passed value is just the initial value to be memoized."}),"\n",(0,o.jsx)(n.p,{children:"The memoized value doesn't change when some dependency (input) change, it doesn't even have a dependency array. Instead it gives us a dedicated function for changing the memoized value. And this function not only updates the memoized value but also triggers the re-render of the component."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:"showLineNumbers",children:"function UserComponent({ user: usr }) {\n  const [\n    // \ud83d\udc47 This value is memoized\n    // highlight-next-line\n    user,\n    setUser,\n  ] = useState(usr);\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"useeffect",children:(0,o.jsx)(n.code,{children:"useEffect"})}),"\n",(0,o.jsx)(n.p,{children:"This hook memoizes the side-effect. Yeah it sounds weird, basically, we're telling react, to run this callback anytime the dependency values change."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",metastring:"showLineNumbers",children:"function UserComponent({ user }) {\n  useEffect(\n    // \ud83d\udc47 This function (side-effect) is memoized\n    // highlight-next-line\n    () => doSomething(),\n    [user],\n  );\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var s=t(6540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);