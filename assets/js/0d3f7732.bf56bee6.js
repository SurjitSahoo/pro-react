"use strict";(self.webpackChunkpro_react=self.webpackChunkpro_react||[]).push([[8277],{7583:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"performance/use-effect-is-dangerous","title":"useEffect is Dangerous! \ud83e\udde8\ud83d\udca3","description":"Always avoid using useEffect if you have any alternate solution.","source":"@site/docs/4.performance/3.use-effect-is-dangerous.md","sourceDirName":"4.performance","slug":"/performance/use-effect-is-dangerous","permalink":"/pro-react/docs/performance/use-effect-is-dangerous","draft":false,"unlisted":false,"editUrl":"https://github.com/SurjitSahoo/pro-react/edit/main/docs/4.performance/3.use-effect-is-dangerous.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"slug":"use-effect-is-dangerous"},"sidebar":"tutorialSidebar","previous":{"title":"What Are Hooks? \ud83e\ude9d","permalink":"/pro-react/docs/performance/what-are-hooks"},"next":{"title":"How to think about useEffect","permalink":"/pro-react/docs/performance/how-to-think-about-use-effect"}}');var r=t(4848),a=t(8453);const i={sidebar_position:3,slug:"use-effect-is-dangerous"},o="useEffect is Dangerous! \ud83e\udde8\ud83d\udca3",d={},l=[{value:"Common pitfalls",id:"common-pitfalls",level:2},{value:"Don&#39;t use it to update the local state if the props change.",id:"dont-use-it-to-update-the-local-state-if-the-props-change",level:3},{value:"Don&#39;t use <code>useEffect</code> for maintaining derived state",id:"dont-use-useeffect-for-maintaining-derived-state",level:3},{value:"Read: Why useMemo helps improve performance in this case",id:"read-why-usememo-helps-improve-performance-in-this-case",level:4},{value:"Avoid <code>useEffect</code> for event driven functionality",id:"avoid-useeffect-for-event-driven-functionality",level:3},{value:"There are many problems with the above code, I&#39;ll list down a few",id:"there-are-many-problems-with-the-above-code-ill-list-down-a-few",level:4},{value:"Don&#39;t use prop destructured values in useEffect dependency array",id:"dont-use-prop-destructured-values-in-useeffect-dependency-array",level:3},{value:"Don&#39;t use <code>useEffect</code> to reset all the states when some prop changes.",id:"dont-use-useeffect-to-reset-all-the-states-when-some-prop-changes",level:3},{value:"Don&#39;t chain <code>useEffects</code>",id:"dont-chain-useeffects",level:3}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsxs)(n.h1,{id:"useeffect-is-dangerous-",children:[(0,r.jsx)(n.code,{children:"useEffect"})," is Dangerous! \ud83e\udde8\ud83d\udca3"]})}),"\n",(0,r.jsx)(n.admonition,{type:"danger",children:(0,r.jsxs)(n.p,{children:["Always avoid using ",(0,r.jsx)(n.code,{children:"useEffect"})," if you have any alternate solution."]})}),"\n",(0,r.jsx)(n.admonition,{title:"Remember \ud83e\udde0",type:"info",children:(0,r.jsx)(n.p,{children:"It runs only after the commit phase, i.e after the re-render changes have been committed to the DOM."})}),"\n",(0,r.jsx)(n.h2,{id:"common-pitfalls",children:"Common pitfalls"}),"\n",(0,r.jsx)(n.h3,{id:"dont-use-it-to-update-the-local-state-if-the-props-change",children:"Don't use it to update the local state if the props change."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Message({ msg }) {\n  const [msgState, setMsgState] = useState(msg);\n\n  useEffect(() => setMsgState(msg), [msg]);\n\n  return <div>{msgState}</div>;\n}\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When the ",(0,r.jsx)(n.code,{children:"msg"})," prop changes from parent, it'll call the ",(0,r.jsx)(n.code,{children:"<Message/>"})," component-function again passing the new updated ",(0,r.jsx)(n.code,{children:"msg"})," (re-render triggered)."]}),"\n",(0,r.jsxs)(n.li,{children:["Then Message component will re-render by re-calculating the changes in the UI elements, and commit the changes to the browser. Only after that, your ",(0,r.jsx)(n.code,{children:"useEffect"})," will run, setting the new msg in the state. That will again trigger re-render. But you already got the updated msg in previous render, you do not need another re-render!!"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DO \u2705"',children:"function Message({ msg }) {\n  return <div>{msg}</div>;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"dont-use-useeffect-for-maintaining-derived-state",children:["Don't use ",(0,r.jsx)(n.code,{children:"useEffect"})," for maintaining derived state"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T - Example 1 \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Message({ error }) {\n  const [msgState, setMsgState] = useState('');\n\n  useEffect(() => setMsgState(`${error.status}: Something went wrong.`), [error]);\n\n  return <div>{msgState}</div>;\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Derived State",type:"tip",children:(0,r.jsxs)(n.p,{children:["A derived value from other state(s) is called a derived state.",(0,r.jsx)(n.br,{}),"\n","Here the ",(0,r.jsx)(n.code,{children:"error"})," is the prop or can be a state and the ",(0,r.jsx)(n.code,{children:"msgState"})," is the derived state."]})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When the ",(0,r.jsx)(n.code,{children:"error"})," prop changes from parent, it'll call the ",(0,r.jsx)(n.code,{children:"<Message/>"})," component-function again passing the new updated ",(0,r.jsx)(n.code,{children:"error"})," object (re-render triggered)."]}),"\n",(0,r.jsxs)(n.li,{children:["Then Message component will re-render by re-calculating the changes in the UI elements, and commit the changes to the browser. Only after that, your ",(0,r.jsx)(n.code,{children:"useEffect"})," will run, setting the new msg in the state. That will again trigger re-render. But you already got the updated error object in previous render, you do not need another re-render!!"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="If the derived state is a simple computation \u2705"',children:"function Message({ error }) {\n  const msg = `${error.status}: Something went wrong.`;\n\n  return <div>{msg}</div>;\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="If the derived state is an expensive computation \u2705"',children:"function Message({ error }) {\n  const msg = useMemo(() => `${error.status}: Something went wrong.`, [error.status]);\n\n  return <div>{msg}</div>;\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"read-why-usememo-helps-improve-performance-in-this-case",children:(0,r.jsx)(n.a,{href:"/pro-react/docs/performance/what-are-hooks#usememo",children:"Read: Why useMemo helps improve performance in this case"})}),"\n",(0,r.jsx)("h4",{style:{color:"#ff4c4c"},children:"Guess how many re-renders will it take to update the screen correctly when both firstName and lastName change!"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T - Example 2 \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Form() {\n  const [firstName, setFirstName] = useState('Taylor');\n  const [lastName, setLastName] = useState('Swift');\n  // \ud83d\udca9 Avoid: redundant state and unnecessary Effect\n  const [fullName, setFullName] = useState('');\n\n  useEffect(() => {\n    // small computation\n    // highlight-next-line\n    setFullName(firstName + ' ' + lastName);\n  }, [firstName, lastName]);\n\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)(n.p,{children:"Answer: How many re-renders?"})}),(0,r.jsxs)(n.p,{children:["Problem: When ",(0,r.jsx)(n.code,{children:"firstName"})," or ",(0,r.jsx)(n.code,{children:"lastName"})," change, it'll trigger a re-render, but useEffect will only run after the changes have been committed to the DOM. Then useEffect will set a state which will again trigger a re-render."]}),(0,r.jsxs)(n.p,{children:["Of course the ",(0,r.jsx)(n.code,{children:"firstName"})," and ",(0,r.jsx)(n.code,{children:"lastName"})," both wont change at the exact same time. There will be some delay in between. Now lets count.."]}),(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"What triggered re-render"}),(0,r.jsx)(n.th,{children:"render / re-render count"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"firstName"})," changes"]}),(0,r.jsx)(n.td,{children:"1"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," triggered by ",(0,r.jsx)(n.code,{children:"firstName"})," change, updates ",(0,r.jsx)(n.code,{children:"fullName"})]}),(0,r.jsx)(n.td,{children:"2"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"lastName"})," changes"]}),(0,r.jsx)(n.td,{children:"3"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"useEffect"})," triggered by ",(0,r.jsx)(n.code,{children:"lastName"})," change, updates ",(0,r.jsx)(n.code,{children:"fullName"})]}),(0,r.jsx)(n.td,{children:"4"})]})]})]}),(0,r.jsx)(n.admonition,{title:"\ud83d\udca9\ud83e\udde8\ud83d\udca3",type:"danger",children:(0,r.jsx)(n.p,{children:"Imagine if there was 1 more dependency or 2 more dependencies!"})})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DO \u2705"',children:"function Form() {\n  const [firstName, setFirstName] = useState('Taylor');\n  const [lastName, setLastName] = useState('Swift');\n  // \u2705 Good: calculated during rendering\n  const fullName = firstName + ' ' + lastName;\n\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:["Only use ",(0,r.jsx)(n.code,{children:"useMemo"})," when the computation is expensive."]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function TodoList({ todos, filter }) {\n  // \ud83d\udca9 Avoid: redundant state and unnecessary Effect\n  const [visibleTodos, setVisibleTodos] = useState([]);\n\n  useEffect(() => {\n    // some expensive computation\n    // highlight-next-line\n    const filteredTodos = getFilteredTodos(todos, filter);\n    setVisibleTodos(filteredTodos);\n  }, [todos, filter]);\n\n  // ...\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DO \u2705"',children:"function TodoList({ todos, filter }) {\n  const [newTodo, setNewTodo] = useState('');\n  const visibleTodos = useMemo(\n    () =>\n      // some expensive computation\n      // highlight-next-line\n      getFilteredTodos(todos, filter),\n    [todos, filter],\n  );\n\n  // ...\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"avoid-useeffect-for-event-driven-functionality",children:["Avoid ",(0,r.jsx)(n.code,{children:"useEffect"})," for event driven functionality"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Message({ msg, updateMsg }) {\n  const [msgInput, setMsgInput] = useState(msg);\n\n  useEffect(() => {\n    updateMsg(msgInput);\n  }, [msgInput]);\n\n  const onMsgChange = e => setMsgInput(e.target.value);\n\n  return (\n    <>\n      <input value={msgInput} onChange={onMsgChange} />\n    </>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"there-are-many-problems-with-the-above-code-ill-list-down-a-few",children:"There are many problems with the above code, I'll list down a few"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If you are using ",(0,r.jsx)(n.code,{children:"eslint"}),", it'll complain: ",(0,r.jsx)(n.code,{children:"updateMsg"})," is not provided in the dependency list at line no: 6.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["How to fix this issue? Disable ",(0,r.jsx)(n.code,{children:"eslint"}),"?"]}),"\n",(0,r.jsxs)(n.li,{children:["NO!! eslint is complaining because ",(0,r.jsx)(n.code,{children:"updateMsg"})," is a prop coming from parent, what if the parent updates the function at some point? And the callback we are passing to the ",(0,r.jsx)(n.code,{children:"useEffect"})," gets memoized! (",(0,r.jsx)(n.a,{href:"/pro-react/docs/performance/what-are-hooks#useeffect",children:"we're memoizing the side-effect remember?"}),"), so when this callback gets executed, it wont get the latest version of the ",(0,r.jsx)(n.code,{children:"updateMsg"})," function."]}),"\n",(0,r.jsx)(n.li,{children:"If we want the latest version, we do need to add it to the dependency array!"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["But if we add ",(0,r.jsx)(n.code,{children:"updateMsg"})," into the dependency array, we'll have another problem. Because it's an argument of our component function, on every re-render this variable will be re-defined, which will trigger \"useEffect\" and we'll get infinite loop. There are two ways to fix this.","\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["wrap it with ",(0,r.jsx)(n.code,{children:"useCallback"})," to memoize the prop. but it'll again have some other implications. And additionally it needs to run more checks on every re-render for memoization purposes."]}),"\n",(0,r.jsxs)(n.li,{children:["Store it in a ref. Eslint won't ask you to add it to dependency array. If ",(0,r.jsx)(n.code,{children:"updateMsg"})," does change, it won't trigger a re-render. And we'll always get the latest version of the function."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="Example with useRef \u2705"',children:"function Message({ msg, updateMsg }) {\n  const [msgInput, setMsgInput] = useState(msg);\n  const updateMsgRef = useRef(updateMsg);\n\n  useEffect(() => {\n    updateMsgRef.current(msgInput);\n  }, [msgInput]);\n\n  const onMsgChange = e => setMsgInput(e.target.value);\n\n  return (\n    <>\n      <input value={msgInput} onChange={onMsgChange} />\n    </>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"It's not good enough",type:"warning",children:(0,r.jsx)(n.p,{children:"The above solution still relies on the re-render cycle of the component. Because it'll run only after the component has re-rendered. So it's better to remove the \"useEffect\" all-together."})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="Event Driven Solution \u2705"',children:"function Message({ msg, updateMsg }) {\n  const [msgInput, setMsgInput] = useState(msg);\n\n  const onMsgChange = e => setMsgInput(e.target.value);\n  const updateParent = () => updateMsg(msgInput);\n\n  return (\n    <>\n      <input value={msgInput} onChange={onMsgChange} />\n      <button onClick={updateParent}>Submit</button>\n    </>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Always try to implement event driven solution",type:"tip",children:(0,r.jsxs)(n.p,{children:["Most often, the initial data fetching might need a ",(0,r.jsx)(n.code,{children:"useEffect"}),",",(0,r.jsx)(n.br,{}),"\n","but after that everything happens based on some user interaction. The user scrolls or clicks something or drags something etc. Execute your functions in the event handlers of these user-events."]})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"dont-use-prop-destructured-values-in-useeffect-dependency-array",children:"Don't use prop destructured values in useEffect dependency array"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Message(props) {\n  const { msg } = props;\n  useEffect(() => {\n    // do something\n  }, [msg]);\n\n  return null;\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"infinite loop",type:"warning",children:(0,r.jsxs)(n.p,{children:["Whenever the component re-renders, it'll re-define the msg variable, which will trigger ",(0,r.jsx)(n.code,{children:"useEffect"})," again and again. Memoize it if you really need, otherwise find an alternate solution not involving useEffect."]})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"dont-use-useeffect-to-reset-all-the-states-when-some-prop-changes",children:["Don't use ",(0,r.jsx)(n.code,{children:"useEffect"})," to reset all the states when some prop changes."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Profile({ userId }) {\n  const [userName, setUserName] = useState();\n  const [email, setEmail] = useState();\n\n  useEffect(() => {\n    setUserName(null);\n    setEmail(null);\n  }, [userId]);\n\n  return null;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It's inefficient, when the ",(0,r.jsx)(n.code,{children:"userId"})," changes, the component will be re-rendered first, and only after the re-render ",(0,r.jsx)(n.code,{children:"useEffect"})," will run and reset the states, which will trigger another re-render."]}),"\n",(0,r.jsxs)(n.p,{children:["Instead, pass a unique key prop to the ",(0,r.jsx)(n.code,{children:"<Profile />"})," component from the parent, so that when the key changes, react will treat it as a brand new component, it'll discard the old component and create a new instance where all the states will be already reset with initial values."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DO \u2705"',children:"function Parent() {\n  const userId = useUserId();\n\n  return (\n    <Profile\n      // highlight-next-line\n      key={userId}\n      userId={userId}\n    />\n  );\n}\n\nfunction Profile({ userId }) {\n  const [userName, setUserName] = useState();\n  const [email, setEmail] = useState();\n\n  return null;\n}\n"})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h3,{id:"dont-chain-useeffects",children:["Don't chain ",(0,r.jsx)(n.code,{children:"useEffects"})]}),"\n",(0,r.jsx)(n.p,{children:"useEffect"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DON\'T \ud83d\udca9\ud83e\udde8\ud83d\udca3"',children:"function Game() {\n  const [card, setCard] = useState(null);\n  const [goldCardCount, setGoldCardCount] = useState(0);\n  const [round, setRound] = useState(1);\n  const [isGameOver, setIsGameOver] = useState(false);\n\n  // \ud83d\udca9 Avoid: Chains of Effects that adjust the state solely to trigger each other\n  // highlight-next-line\n  // \ud83d\udca9\ud83d\udca9 Chain: card change -> goldCardCount update -> round update -> isGameOver update -> Alert UI\n  useEffect(() => {\n    if (card !== null && card.gold) {\n      setGoldCardCount(c => c + 1);\n    }\n  }, [card]);\n\n  useEffect(() => {\n    if (goldCardCount > 3) {\n      setRound(r => r + 1);\n      setGoldCardCount(0);\n    }\n  }, [goldCardCount]);\n\n  useEffect(() => {\n    if (round > 5) {\n      setIsGameOver(true);\n    }\n  }, [round]);\n\n  useEffect(() => {\n    alert('Good game!');\n  }, [isGameOver]);\n\n  function handlePlaceCard(nextCard) {\n    if (isGameOver) {\n      throw Error('Game already ended.');\n    } else {\n      setCard(nextCard);\n    }\n  }\n\n  return <div>Game UI</div>;\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"If one state change affects another state change, which then again affects another and another and another.. Then all of these can probably be wrapped up into a single function"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'showLineNumbers title="DO \u2705"',children:"function Game() {\n  const [card, setCard] = useState(null);\n  const [goldCardCount, setGoldCardCount] = useState(0);\n  const [round, setRound] = useState(1);\n\n  const isGameOver = round > 5;\n\n  function handlePlaceCard(nextCard) {\n    if (isGameOver) {\n      throw Error('Game already ended.');\n    }\n\n    // \u2705 Calculate all the next state in the event handler\n    setCard(nextCard);\n    if (nextCard.gold) {\n      if (goldCardCount <= 3) {\n        setGoldCardCount(goldCardCount + 1);\n      } else {\n        setGoldCardCount(0);\n        setRound(round + 1);\n        if (round === 5) {\n          alert('Good game!');\n        }\n      }\n    }\n  }\n\n  return <div>Game UI</div>;\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);