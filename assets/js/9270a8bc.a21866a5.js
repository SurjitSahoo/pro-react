"use strict";(self.webpackChunkpro_react=self.webpackChunkpro_react||[]).push([[9017],{6979:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>l,frontMatter:()=>c,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"architecture/state-management/api-and-caching","title":"APIs and Caching","description":"Caching API calls is important for performance and user experience. For example, if you fetch data in TABA, switch to TABB to fetch different data, and then quickly return to TAB_A, you typically don\'t need to refetch the data again if it hasn\'t changed. Instead, reuse the cached data and render the content. If necessary, refetch it in the background and only update the UI if the data has changed; otherwise, continue displaying the cached data.","source":"@site/docs/1.architecture/6.state-management/4.api-and-caching.md","sourceDirName":"1.architecture/6.state-management","slug":"/architecture/state-management/cached-api","permalink":"/pro-react/docs/architecture/state-management/cached-api","draft":false,"unlisted":false,"editUrl":"https://github.com/SurjitSahoo/pro-react/edit/main/docs/1.architecture/6.state-management/4.api-and-caching.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"APIs and Caching","slug":"cached-api"},"sidebar":"tutorialSidebar","previous":{"title":"Decouple UI from State","permalink":"/pro-react/docs/architecture/state-management/decouple-ui-from-state-using-global-state"},"next":{"title":"Misc Structural Guidelines","permalink":"/pro-react/docs/category/misc-structural-guidelines"}}');var r=t(4848),o=t(8453);const c={sidebar_position:4,title:"APIs and Caching",slug:"cached-api"},s="API handling and Caching",i={},d=[{value:"Cached API Handler",id:"cached-api-handler",level:2},{value:"Implementing Cached API Handlers",id:"implementing-cached-api-handlers",level:2},{value:"Third Party Libraries",id:"third-party-libraries",level:3},{value:"Own implementation",id:"own-implementation",level:3},{value:"Usage Examples",id:"usage-examples",level:4}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"api-handling-and-caching",children:"API handling and Caching"})}),"\n",(0,r.jsx)(n.p,{children:"Caching API calls is important for performance and user experience. For example, if you fetch data in TAB_A, switch to TAB_B to fetch different data, and then quickly return to TAB_A, you typically don't need to refetch the data again if it hasn't changed. Instead, reuse the cached data and render the content. If necessary, refetch it in the background and only update the UI if the data has changed; otherwise, continue displaying the cached data."}),"\n",(0,r.jsx)(n.h2,{id:"cached-api-handler",children:"Cached API Handler"}),"\n",(0,r.jsx)(n.p,{children:"The API handler should be a custom hook, that internally manages:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Triggering API calls on component mount."}),"\n",(0,r.jsx)(n.li,{children:"Cache the API data and manage cache internally."}),"\n",(0,r.jsx)(n.li,{children:"Refetch the data in the background at configured intervals or when the cache expires or becomes invalid. And only update the managed state when the API data actually changes, to minimize component re-renders."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'title="API handler usage"',children:"export const Posts = () => {\n  const { isLoading, isError, data: posts } = usePosts();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (isError || !data) return <div>Something went wrong while loading posts.</div>;\n\n  return (\n    <div>\n      {posts.map(post => (\n        <div key={post.id}>\n          <h1>{post.title}</h1>\n          <p>{post.content}</p>\n        </div>\n      ))}\n    </div>\n  );\n};\n"})}),"\n",(0,r.jsxs)(n.admonition,{title:"DON'T",type:"danger",children:[(0,r.jsx)(n.p,{children:"If an API response is needed in more than 1 components which are deeply nested in the DOM tree. Do not call the api in the top parent component that doesn't even need that data, then pass that data to the children components as prop drilling."}),(0,r.jsx)(n.p,{children:"Do not store store the data in browser storage then access them in the child components - this makes the component really hard to test."}),(0,r.jsx)(n.p,{children:"Do not set the data in some global state from parent, and access them from children components. It's not clean."}),(0,r.jsx)(n.p,{children:"Do not call the API in one of the child and set it in global state to access it from another child. This requires the chronology of component mounts to remain same. If the dependent component mounts first, then it wont find the data."})]}),"\n",(0,r.jsxs)(n.admonition,{title:"DO",type:"tip",children:[(0,r.jsx)(n.p,{children:"Check if the data already exists in the cache, if not trigger the API call and set the appropriate states. All of this can be handled in the custom hook internally as lower level details."}),(0,r.jsx)(n.p,{children:"The UI component only needs to call the hook and use the states: isLoading, isError, data etc. Each component that needs this data can use this custom hook, without being tightly coupled with any other component."})]}),"\n",(0,r.jsx)(n.h2,{id:"implementing-cached-api-handlers",children:"Implementing Cached API Handlers"}),"\n",(0,r.jsx)(n.h3,{id:"third-party-libraries",children:"Third Party Libraries"}),"\n",(0,r.jsx)(n.p,{children:"Utilize battle tested, community maintained, open source 3rd party libraries if you don't want to re-invent the wheel."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://tanstack.com/query/latest",children:"TanStack Query - formerly known as react-query"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://redux-toolkit.js.org/rtk-query/overview",children:"redux-toolkit query (RTK Query)"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"own-implementation",children:"Own implementation"}),"\n",(0,r.jsx)(n.p,{children:"If you want a simple cached API handlers and don't need all the advanced features offered by the above 3rd party libraries, you can implement something as follows."}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsxs)(n.p,{children:["custom ",(0,r.jsx)(n.code,{children:"useCachedFetch"})," hook"]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="useCachedFetch.js"',children:"import { useState, useEffect, useCallback, useRef } from 'react';\n\n// Global cache store\nconst cache = new Map();\n\n/**\n * Custom hook for fetching data with caching capabilities\n * @param {string} url - The URL to fetch from\n * @param {Object} options - Configuration options\n * @param {string} options.method - HTTP method (GET, POST, PUT, DELETE, etc.)\n * @param {Object} options.headers - Request headers\n * @param {any} options.body - Request body for POST/PUT requests\n * @param {boolean} options.cache - Whether to cache the response (default: true)\n * @param {boolean} options.preferCache - Whether to prefer cached data over fresh fetch (default: true)\n * @param {number} options.cacheTimeout - Cache timeout in milliseconds (default: 5 minutes)\n * @param {Array} options.dependencies - Dependencies that trigger refetch when changed\n * @param {boolean} options.enabled - Whether the fetch should be enabled (default: true)\n */\nexport const useCachedFetch = (url, options = {}) => {\n  const {\n    method = 'GET',\n    headers = {},\n    body = null,\n    cache: shouldCache = true,\n    preferCache = true,\n    cacheTimeout = 5 * 60 * 1000, // 5 minutes\n    dependencies = [],\n    enabled = true,\n  } = options;\n\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Create a unique cache key based on URL, method, and body\n  const cacheKey = useRef();\n  const abortControllerRef = useRef();\n\n  // Generate cache key\n  const generateCacheKey = useCallback(() => {\n    const bodyStr = body ? JSON.stringify(body) : '';\n    const headersStr = JSON.stringify(headers);\n    return `${method}:${url}:${bodyStr}:${headersStr}`;\n  }, [url, method, body, headers]);\n\n  // Check if cached data is still valid\n  const isCacheValid = useCallback(\n    cachedItem => {\n      if (!cachedItem) return false;\n      const now = Date.now();\n      return now - cachedItem.timestamp < cacheTimeout;\n    },\n    [cacheTimeout],\n  );\n\n  // Get data from cache\n  const getCachedData = useCallback(\n    key => {\n      const cachedItem = cache.get(key);\n      if (cachedItem && isCacheValid(cachedItem)) {\n        return cachedItem.data;\n      }\n      return null;\n    },\n    [isCacheValid],\n  );\n\n  // Set data in cache\n  const setCachedData = useCallback(\n    (key, data) => {\n      if (shouldCache) {\n        cache.set(key, {\n          data,\n          timestamp: Date.now(),\n        });\n      }\n    },\n    [shouldCache],\n  );\n\n  // Clear cache entry\n  const clearCacheEntry = useCallback(key => {\n    cache.delete(key);\n  }, []);\n\n  // Main fetch function\n  const fetchData = useCallback(\n    async (forceRefresh = false) => {\n      if (!enabled || !url) return;\n\n      const key = generateCacheKey();\n      cacheKey.current = key;\n\n      // Check cache first if preferCache is true and not forcing refresh\n      if (preferCache && !forceRefresh && shouldCache) {\n        const cachedData = getCachedData(key);\n        if (cachedData) {\n          setData(cachedData);\n          setError(null);\n          return cachedData;\n        }\n      }\n\n      // Cancel previous request if it exists\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n\n      // Create new abort controller\n      abortControllerRef.current = new AbortController();\n\n      try {\n        setLoading(true);\n        setError(null);\n\n        const fetchOptions = {\n          method,\n          headers: {\n            'Content-Type': 'application/json',\n            ...headers,\n          },\n          signal: abortControllerRef.current.signal,\n        };\n\n        // Add body for non-GET requests\n        if (body && method !== 'GET') {\n          fetchOptions.body = typeof body === 'string' ? body : JSON.stringify(body);\n        }\n\n        const response = await fetch(url, fetchOptions);\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        // Try to parse as JSON, fallback to text\n        let responseData;\n        const contentType = response.headers.get('content-type');\n\n        if (contentType && contentType.includes('application/json')) {\n          responseData = await response.json();\n        } else {\n          responseData = await response.text();\n        }\n\n        // Cache the data\n        setCachedData(key, responseData);\n\n        setData(responseData);\n        setLoading(false);\n\n        return responseData;\n      } catch (err) {\n        // Don't set error if request was aborted\n        if (err.name !== 'AbortError') {\n          setError(err.message);\n          setLoading(false);\n        }\n        throw err;\n      }\n    },\n    [enabled, url, generateCacheKey, preferCache, shouldCache, getCachedData, setCachedData, method, headers, body],\n  );\n\n  // Refetch function that forces a fresh request\n  const refetch = useCallback(() => {\n    return fetchData(true);\n  }, [fetchData]);\n\n  // Clear cache for current request\n  const clearCache = useCallback(() => {\n    if (cacheKey.current) {\n      clearCacheEntry(cacheKey.current);\n    }\n  }, [clearCacheEntry]);\n\n  // Effect to trigger fetch on mount and dependency changes\n  useEffect(() => {\n    if (enabled) {\n      fetchData();\n    }\n\n    // Cleanup function\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, [enabled, url, method, JSON.stringify(body), JSON.stringify(headers), ...dependencies]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n    };\n  }, []);\n\n  return {\n    data,\n    loading,\n    error,\n    refetch,\n    clearCache,\n    // Utility functions\n    isFromCache: preferCache && shouldCache && data && getCachedData(generateCacheKey()) === data,\n  };\n};\n\n// Utility function to clear all cache\nexport const clearAllCache = () => {\n  cache.clear();\n};\n\n// Utility function to get cache size\nexport const getCacheSize = () => {\n  return cache.size;\n};\n\n// Utility function to get all cache keys\nexport const getCacheKeys = () => {\n  return Array.from(cache.keys());\n};\n"})})]}),"\n",(0,r.jsx)(n.h4,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",metastring:'title="Usage Example 1"',children:"const { data: users, loading, error, refetch, isFromCache } = useCachedFetch('https://jsonplaceholder.typicode.com/users');\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="Usage Example 2"',children:"const [selectedUserId, setSelectedUserId] = useState<number | null>(null);\n\nconst {\n  data: posts,\n  loading,\n  error,\n  clearCache,\n} = useCachedFetch(`https://jsonplaceholder.typicode.com/posts?userId=${selectedUserId}`, {\n  enabled: !!selectedUserId,\n  dependencies: [selectedUserId],\n  cacheTimeout: 2 * 60 * 1000, // 2 minutes\n});\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="Usage Example 3"',children:"const [formData, setFormData] = useState({\n  title: '',\n  body: '',\n  userId: 1,\n});\nconst [shouldSubmit, setShouldSubmit] = useState(false);\n\nconst {\n  data: response,\n  loading,\n  error,\n} = useCachedFetch<Post>('https://jsonplaceholder.typicode.com/posts', {\n  method: 'POST',\n  body: formData,\n  cache: false, // Don't cache POST responses\n  enabled: shouldSubmit,\n  dependencies: [shouldSubmit],\n});\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.mdxAdmonitionTitle,{children:(0,r.jsx)(n.a,{href:"/pro-react/docs/architecture/how-to-structure-react-application",children:"Follow this application structure guide to organize the API handlers"})})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>s});var a=t(6540);const r={},o=a.createContext(r);function c(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);