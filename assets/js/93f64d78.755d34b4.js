"use strict";(self.webpackChunkpro_react=self.webpackChunkpro_react||[]).push([[9414],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var a=n(6540);const o={},s=a.createContext(o);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},8499:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"architecture/state-management/global-state","title":"Decouple UI from State","description":"When it comes to global state management in react, there\'s no opinionated solution on the topic. But currently redux is by far the most popular library. How we use redux in our react applications has gone through many changes and evolved over the past few years.","source":"@site/docs/1.architecture/6.state-management/3.global-state.md","sourceDirName":"1.architecture/6.state-management","slug":"/architecture/state-management/decouple-ui-from-state-using-global-state","permalink":"/pro-react/docs/architecture/state-management/decouple-ui-from-state-using-global-state","draft":false,"unlisted":false,"editUrl":"https://github.com/SurjitSahoo/pro-react/edit/main/docs/1.architecture/6.state-management/3.global-state.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Decouple UI from State","slug":"decouple-ui-from-state-using-global-state"},"sidebar":"tutorialSidebar","previous":{"title":"global-state-redux","permalink":"/pro-react/docs/architecture/state-management/global-state-redux"},"next":{"title":"APIs and Caching","permalink":"/pro-react/docs/architecture/state-management/cached-api"}}');var o=n(4848),s=n(8453);const r={sidebar_position:3,title:"Decouple UI from State",slug:"decouple-ui-from-state-using-global-state"},i="Global State",c={},l=[{value:"How to decouple UI from state management?",id:"how-to-decouple-ui-from-state-management",level:2},{value:"Implementation of abstract global state using redux",id:"implementation-of-abstract-global-state-using-redux",level:3},{value:"Implementation of abstract global state using zustand",id:"implementation-of-abstract-global-state-using-zustand",level:3},{value:"Hide the framework / library details from the application",id:"hide-the-framework--library-details-from-the-application",level:2}];function u(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"global-state",children:"Global State"})}),"\n",(0,o.jsx)(t.p,{children:"When it comes to global state management in react, there's no opinionated solution on the topic. But currently redux is by far the most popular library. How we use redux in our react applications has gone through many changes and evolved over the past few years."}),"\n",(0,o.jsx)(t.p,{children:"Tomorrow there might be another big change, a better way to use redux, Or maybe a different all-new library comes out, and that becomes the norm. Then what do we do? How do we upgrade, and how do we maintain our projects?"}),"\n",(0,o.jsx)(t.p,{children:"Should we change every single file/component that uses the global state? It sounds like a really bad idea!"}),"\n",(0,o.jsx)(t.admonition,{title:"Decouple UI from state",type:"tip",children:(0,o.jsx)(t.p,{children:"Global State can help you separate and abstract all the state management logic away from the UI components. This can help decouple the UI components."})}),"\n",(0,o.jsx)(t.h2,{id:"how-to-decouple-ui-from-state-management",children:"How to decouple UI from state management?"}),"\n",(0,o.jsx)(t.p,{children:"Using global state management libraries such as redux, we can abstract the state management logic away from the UI components. This way, we can change the implementation of the global state management library without affecting the UI components."}),"\n",(0,o.jsx)(t.p,{children:"The react components should not need to know how the global state is managed, they should only know how to read the state and how to update the state."}),"\n",(0,o.jsx)(t.p,{children:"Whether we use redux, zustand, xState, jotai, signals or any other global state management library, these are lower level details. The UI components should not need to know about it."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",metastring:'title="example"',children:"import { useCount } from 'globalState/clientState/count';\n\nexport function CountComponent() {\n  const { count, increment, decrement, reset } = useCount();\n\n  return (\n    <>\n      <div>Global Count: {count}</div>\n      <button onClick={increment}>increment</button>\n      <button onClick={decrement}>decrement</button>\n      <button onClick={reset}>reset</button>\n    </>\n  );\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In the above example, the ",(0,o.jsx)(t.code,{children:"CountComponent"})," imports and uses a custom hook. How that hook works internally is not important to the ",(0,o.jsx)(t.code,{children:"CountComponent"}),". The ",(0,o.jsx)(t.code,{children:"CountComponent"})," only cares about the state and how to update it."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"useCount"})," hook can be implemented using any global state management library, such as redux, zustand, xState, jotai, signals or any other library."]}),"\n",(0,o.jsx)(t.h3,{id:"implementation-of-abstract-global-state-using-redux",children:"Implementation of abstract global state using redux"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",metastring:'title="\ud83d\udcc1 globalState/clientState/count.js"',children:"import { createSlice } from '@reduxjs/toolkit';\nimport { useDispatch, useSelect } from 'react-redux';\n\n// create the redux slice\nconst countSlice = createSlice({\n  name: 'count',\n  initialState: { count: 0 },\n  reducers: {\n    increment(state) {\n      state.count += 1;\n    },\n    decrement(state) {\n      state.count -= 1;\n    },\n    clear(state) {\n      state.count = 0;\n    },\n  },\n});\n\nconst { increment, decrement, clear } = countSlice.actions; // NOTICE, I'M NOT EXPORTING THE ACTIONS\n\nexport function useCount() {\n  const dispatch = useDispatch();\n  const count = useSelect(state => state.count.count);\n\n  return {\n    count,\n    increment: () => dispatch(increment()),\n    decrement: () => dispatch(decrement()),\n    reset: () => dispatch(clear()),\n  };\n}\n\nexport default countSlice.reducer; // needed for connecting this slice to redux-store\n"})}),"\n",(0,o.jsx)(t.h3,{id:"implementation-of-abstract-global-state-using-zustand",children:"Implementation of abstract global state using zustand"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",metastring:'title="\ud83d\udcc1 globalState/clientState/count.js"',children:"import { create } from 'zustand';\n\nexport const useCount = create(set => ({\n  count: 0,\n  increment: () => set(state => ({ count: state.count + 1 })),\n  decrement: () => set(state => ({ count: state.count - 1 })),\n  reset: () => set({ count: 0 }),\n}));\n"})}),"\n",(0,o.jsx)(t.h2,{id:"hide-the-framework--library-details-from-the-application",children:"Hide the framework / library details from the application"}),"\n",(0,o.jsx)(t.p,{children:"We can organize the global state management library setup in a way that it's abstracted away from the application code."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-txt",metastring:'title="\ud83d\udcc1 globalState folder structure"',children:"globalState\n\u251c\u2500\u2500 core <------------------ core configurations for the global state\n\u2502   \u251c\u2500\u2500 store.ts <---------- redux store (with redux-toolkit)\n\u2502   \u251c\u2500\u2500 provider.tsx <------ redux context provider\n\u2502   \u251c\u2500\u2500 hooks.ts <---------- custom hooks for internal use\n\u2502   \u2514\u2500\u2500 [helper].ts <------- Any helpers if needed\n|\n\u251c\u2500\u2500 clientState <----------- client side state, that has nothing to do with server data\n\u2502   \u2514\u2500\u2500 count.ts <---------- keeping track of count\n|\n\u251c\u2500\u2500 serverState <----------- application state, that relies on server side data fetched from some APIs\n\u2502   \u2514\u2500\u2500 blogsPosts.ts <----- CRUD apis with state-management for blog posts\n|\n\u2514\u2500\u2500 index.ts\n"})}),"\n",(0,o.jsxs)(n,{children:[(0,o.jsx)("summary",{children:"\ud83e\udde8 DON'T DO THESE if you want to keep your components clean and decoupled"}),(0,o.jsx)(t.p,{children:"If you get any value or functions returned form any hook, it's only mean't to be used within that component, and not to be passed down to child components, or to any utility functions which might be called outside the react's lifecycle."}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",metastring:'title="\ud83d\udca9\ud83d\udca9\ud83d\udca9 Worst usage"',children:"import { useNavigate } from 'react-router-dom';\nimport { useDispatch } from 'react-redux';\nimport { someAction } from 'globalStore/actions';\n\nfunction ComponentA() {\n  const navigate = useNavigate();\n  const dispatch = useDispatch();\n\n  const onSomeEvent = () => {\n    dispatch(\n      someAction({\n        dispatch, // \ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\n        navigate, // \ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\n        somePayload,\n      }),\n    );\n  };\n\n  return <button onClick={onSomeEvent}>Click Me</button>;\n}\n"})}),(0,o.jsx)("b",{children:(0,o.jsx)(t.p,{children:"This is a bad practice because it tightly couples the component with the global state management library and the routing library. It's very hard to\ntrack bugs and issues in such code, and it makes the component not reusable at all."})})]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}}}]);