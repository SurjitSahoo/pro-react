"use strict";(self.webpackChunkpro_react=self.webpackChunkpro_react||[]).push([[302],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const s={},i=o.createContext(s);function r(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}},8915:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"architecture/how-to-write-a-component","title":"How to Write a Component","description":"Each component should be as generic as possible. Avoid creating components that are tightly coupled to specific business features or requirements. While you may initially build a component to address a particular business need, treat that as a starting point. After implementing the feature, refactor your code by extracting and splitting it into smaller, more focused components. Continue this process until you cannot extract or split the code any further.","source":"@site/docs/1.architecture/3.how-to-write-a-component.md","sourceDirName":"1.architecture","slug":"/architecture/how-to-write-a-component","permalink":"/pro-react/docs/architecture/how-to-write-a-component","draft":false,"unlisted":false,"editUrl":"https://github.com/SurjitSahoo/pro-react/edit/main/docs/1.architecture/3.how-to-write-a-component.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Single Responsibility Principle","permalink":"/pro-react/docs/architecture/single-responsibility-principle"}}');var s=n(4848),i=n(8453);const r={sidebar_position:2},a="How to Write a Component",c={},l=[{value:"Folder Structure",id:"folder-structure",level:2},{value:"Feature vs Component",id:"feature-vs-component",level:2},{value:"Component",id:"component",level:3},{value:"Feature",id:"feature",level:3},{value:"Additional Learning",id:"additional-learning",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"how-to-write-a-component",children:"How to Write a Component"})}),"\n",(0,s.jsx)(t.p,{children:"Each component should be as generic as possible. Avoid creating components that are tightly coupled to specific business features or requirements. While you may initially build a component to address a particular business need, treat that as a starting point. After implementing the feature, refactor your code by extracting and splitting it into smaller, more focused components. Continue this process until you cannot extract or split the code any further."}),"\n",(0,s.jsx)(t.p,{children:"These smaller components should be designed for maximum reusability, making them easy to use in different scenarios. This approach improves maintainability and scalability across your projects."}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Write once, reuse everywhere."})}),"\n",(0,s.jsx)(t.h2,{id:"folder-structure",children:"Folder Structure"}),"\n",(0,s.jsx)(t.p,{children:"Every component should reside in its own folder. This folder should contain all code related to that component, including:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The main component file"}),"\n",(0,s.jsx)(t.li,{children:"Test files"}),"\n",(0,s.jsx)(t.li,{children:"Styles (CSS/SCSS, etc.)"}),"\n",(0,s.jsx)(t.li,{children:"Storybook files (if any)"}),"\n",(0,s.jsxs)(t.li,{children:["Helper files (with their own tests). If there are multiple helpers, group them in a ",(0,s.jsx)(t.code,{children:"helpers"})," folder."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Helpers are typically needed at the feature level. This is because your components will often require input in a different data structure than what you receive from the API, and they may also output data in a format different from what your API expects. Therefore, you will likely need helper functions to transform data between these formats."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",metastring:'title="Example of clean structure"',children:".\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 button/\n\u2502   \u2502   \u251c\u2500\u2500 button.tsx // component\n\u2502   \u2502   \u251c\u2500\u2500 button.css // styles\n\u2502   \u2502   \u251c\u2500\u2500 button.test.tsx // unit tests\n\u2502   \u2502   \u251c\u2500\u2500 button.stories.tsx // storybook documentation\n\u2502   \u2502   \u2514\u2500\u2500 index.ts // public API, exports button component\n|   |\n\u2502   \u2514\u2500\u2500 modal/\n\u2502       \u251c\u2500\u2500 modal.tsx // component\n\u2502       \u251c\u2500\u2500 modal.css // styles\n\u2502       \u251c\u2500\u2500 modal.test.tsx // unit tests\n\u2502       \u251c\u2500\u2500 modal.stories.tsx // storybook documentation\n\u2502       \u2514\u2500\u2500 index.ts // public API, exports modal component\n|\n\u2514\u2500\u2500 features/\n    \u251c\u2500\u2500 feedbackForm/\n    \u2502   \u251c\u2500\u2500 feedbackForm.tsx // feature component\n    \u2502   \u251c\u2500\u2500 feedbackForm.css // styles\n    \u2502   \u251c\u2500\u2500 feedbackForm.test.tsx // integration tests\n    \u2502   \u251c\u2500\u2500 feedbackForm.stories.tsx // storybook documentation\n    \u2502   \u2514\u2500\u2500 index.ts // public API, exports feedbackForm feature\n    |\n    \u2514\u2500\u2500 feedbackPopup/\n        \u251c\u2500\u2500 feedbackPopup.tsx // feature component\n        \u251c\u2500\u2500 feedbackPopup.css // styles\n        \u251c\u2500\u2500 feedbackPopup.test.tsx // integration tests\n        \u251c\u2500\u2500 feedbackPopup.stories.tsx // storybook documentation\n        \u2514\u2500\u2500 index.ts // public API, exports feedbackForm feature\n"})}),"\n",(0,s.jsx)(t.h2,{id:"feature-vs-component",children:"Feature vs Component"}),"\n",(0,s.jsx)(t.p,{children:"Both are React components, but conceptually they are different."}),"\n",(0,s.jsx)(t.h3,{id:"component",children:"Component"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Components can be thought of as the building blocks for features."}),"\n",(0,s.jsx)(t.li,{children:"Components are generic, their data structures, required props are not business requirement specific. Components should be re-usable in any given scenarios, to create any new business features without ever needing to change the components."}),"\n",(0,s.jsx)(t.li,{children:"Components should be closed for modification, no matter the requirement, components should never need to change."}),"\n",(0,s.jsx)(t.li,{children:"Components have robust unit tests to ensure they work as expect in all the possible scenarios."}),"\n",(0,s.jsx)(t.li,{children:"You might think modal needs a gradient background header and submit/cancel/close buttons and you can configure them through props. No!, cause then it becomes a feature. Gradient background should be a separate component, buttons should be separate components and so on. Modal should just be a modal, that's it!"}),"\n",(0,s.jsx)(t.li,{children:"Components should be small and focused, doing one thing only. Example: button, dropdown, modal, accordion, table, card etc."}),"\n",(0,s.jsx)(t.li,{children:"Components should not interact directly with browser storage; they should receive all necessary data via props."}),"\n",(0,s.jsx)(t.li,{children:"Components should not have margins, as this can limit their flexibility. The feature or parent should control layout and spacing."}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"feature",children:"Feature"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Features are composed using re-usable components as building blocks.","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"A feature decides the arrangement and configuration of the re-usable components to meet the desired feature requirement."}),"\n",(0,s.jsx)(t.li,{children:"When the requirement changes, the arrangement and configuration changes, but the underlying re-usable components / building blocks do not change."}),"\n",(0,s.jsx)(t.li,{children:"Features have integration tests. While these are technically similar to unit tests, their purpose is to verify that the feature works as expected and all underlying components interact together correctly. For example, if your feature uses Redux, you do not test Redux itself, but rather ensure that the feature behaves correctly as a whole."}),"\n",(0,s.jsx)(t.li,{children:"API calls and state handling should be done inside the feature component, not outside the component. API handler function/hook can be defined outside the component but invocation should only happen within the component, respecting the component-lifecycle."}),"\n",(0,s.jsxs)(t.li,{children:["Functions returned from hooks should not be passed as params to helper functions to be invoked outside the component. e.g. ",(0,s.jsx)(t.code,{children:"const dispatch = useDispatch()"}),", here the ",(0,s.jsx)(t.code,{children:"dispatch"})," function should not be passed as param to helper functions to be called from outside the component."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["Helpers should be small, and pure functions organized in the ",(0,s.jsx)(t.code,{children:"helper"})," folders.","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Features can have a lot of logic code, to handle or process the data as per the business requirements, which should be split into several helper functions organized in the ",(0,s.jsx)(t.code,{children:"helpers"})," folders."]}),"\n",(0,s.jsx)(t.li,{children:"Helper functions / utilities should be extracted as generic and re-usable functions and possibly organized outside the feature component as common utils / helpers."}),"\n",(0,s.jsxs)(t.li,{children:["helper functions should be ",(0,s.jsx)(t.strong,{children:"pure functions"}),", i.e. they should not interact with anything external such as states or browser storage etc, everything a helper function needs should be passed as params to the function."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"After building a feature, refactor it by splitting out the UI and logic code into the smallest reusable pieces. Organize similar components and functions into folders as categories. And if there are several related functions, group them as class methods in a class."})}),"\n",(0,s.jsx)(t.h3,{id:"additional-learning",children:"Additional Learning"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://www.youtube.com/playlist?list=PLdTodMosi-BxYqebBBI6JOQitcdUzF4YJ",children:"Clean Code - lecture series by Robert C Martin aka Uncle Bob"})}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);