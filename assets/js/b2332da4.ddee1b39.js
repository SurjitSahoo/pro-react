"use strict";(self.webpackChunkpro_react=self.webpackChunkpro_react||[]).push([[888],{6457:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"performance/class-components-vs-function-components","title":"Class Components Vs Function Components","description":"Class Components","source":"@site/docs/4.performance/1.class-components-vs-function-components.md","sourceDirName":"4.performance","slug":"/performance/class-components-vs-function-components","permalink":"/pro-react/docs/performance/class-components-vs-function-components","draft":false,"unlisted":false,"editUrl":"https://github.com/SurjitSahoo/pro-react/edit/main/docs/4.performance/1.class-components-vs-function-components.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Performance","permalink":"/pro-react/docs/category/performance"},"next":{"title":"What Are Hooks?","permalink":"/pro-react/docs/performance/what-are-hooks"}}');var s=t(4848),r=t(8453);const a={sidebar_position:1},c="Class Components Vs Function Components",i={},d=[{value:"Class Components",id:"class-components",level:2},{value:"Function Components",id:"function-components",level:2}];function p(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"class-components-vs-function-components",children:"Class Components Vs Function Components"})}),"\n",(0,s.jsx)(n.h2,{id:"class-components",children:"Class Components"}),"\n",(0,s.jsxs)(n.p,{children:["Back in the days React components were classes, and the components were following an imperative approach. And with the introduction of hooks, react has moved towards a declarative approach. While it has become easier to create the same component with hooks in significantly less code compared to class components, it has also become way easier to write buggy, slow and unreadable hard-to-understand bad code. ",(0,s.jsx)(n.strong,{children:"So it has become more important than ever to understand how react works."})]}),"\n",(0,s.jsx)(n.p,{children:"In the class components, the UI code is in the render method of the class, and the states, functions, event handlers everything was outside the render method. They were properties or methods of the component class. To re-render a component, it just needs to call the render method, and no function or state variables will be re-created or re-instantiated."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// Simple React class component example\nimport React, { Component } from 'react';\n\nclass Counter extends Component {\n  // State is defined as a property of the class\n  state = {\n    count: 0,\n  };\n\n  // Event handler is a method of the class\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  // UI code is inside the render method\n  // Calling this method wont re-create increment method or the state properties of the class\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"function-components",children:"Function Components"}),"\n",(0,s.jsx)(n.p,{children:"But now that render method has become the entire component. All the states, state-modifier functions, event handlers, life-cycle hooks/functions, everything lives inside that component function. Anytime that component needs to be updated or re-rendered, the component function is executed."}),"\n",(0,s.jsx)(n.p,{children:"But function component is just a javascript function. When a javascript function gets called again, all of its arguments and internal variables/properties, everything get re-created and re-defined. So in the react components all the props, all the functions defined inside the component, all the variables including states, state-modifier function, prop restructured value, everything gets re-created and re-defined."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"import React, { useState } from 'react';\n\n// The entire function body runs on every render,\n// so all variables and functions defined here are re-created each time\nfunction Counter() {\n  // State and state-modifier function are created on every render\n  const [count, setCount] = useState(0);\n\n  // This function is re-created on every render\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n\nexport default Counter;\n"})}),"\n",(0,s.jsx)(n.admonition,{title:"render --\x3e re-create states and functions --\x3e re-render --\x3e repeat \ud83e\udde8\ud83d\udca3",type:"tip",children:(0,s.jsx)(n.p,{children:"But then... wouldn't that trigger infinite re-renders if everything is always being re-created (changed)? Yes, it would. That's where hooks come into the picture."})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);